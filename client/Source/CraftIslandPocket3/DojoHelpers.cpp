// Generated by dojo-bindgen on Sat, 21 Jun 2025 08:16:46 +0000. Do not modify this file manually.

#include "DojoHelpers.h"
#include <string>
#include <iomanip>
#include <sstream>
#include <memory>
#include "Async/Async.h"

using namespace dojo_bindings;

ADojoHelpers* ADojoHelpers::Instance = nullptr;
FCriticalSection ADojoHelpers::InstanceMutex;

// Global memory tracking counters
static int32 GlobalActiveToriiClients = 0;
static int32 GlobalActiveAccounts = 0;
static int32 GlobalActiveProviders = 0;
static int32 GlobalActiveSubscriptions = 0;

ADojoHelpers::ADojoHelpers()
{
    {
        FScopeLock Lock(&InstanceMutex);
        Instance = this;
    }
    subscribed = false;
    toriiClient = nullptr;
    subscription = nullptr;
}

ADojoHelpers::~ADojoHelpers()
{
    CleanupResources();

    {
        FScopeLock Lock(&InstanceMutex);
        if (Instance == this)
        {
            Instance = nullptr;
        }
    }
}

void ADojoHelpers::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
    CleanupResources();
    Super::EndPlay(EndPlayReason);
}

void ADojoHelpers::CleanupResources()
{
    UE_LOG(LogTemp, Log, TEXT("DojoHelpers: Starting resource cleanup"));

    // Cancel subscription if active
    if (subscribed && subscription)
    {
        FDojoModule::SubscriptionCancel(subscription);
        subscription = nullptr;
        subscribed = false;
        GlobalActiveSubscriptions--;
        UE_LOG(LogTemp, Log, TEXT("DojoHelpers: Subscription cancelled"));
    }

    // Free Torii client
    if (toriiClient)
    {
        client_free(toriiClient);
        toriiClient = nullptr;
        GlobalActiveToriiClients--;
        UE_LOG(LogTemp, Log, TEXT("DojoHelpers: Torii client freed"));
    }

    // Free all allocated accounts
    {
        FScopeLock Lock(&ResourceMutex);
        int32 AccountCount = AllocatedAccounts.Num();
        for (Account* account : AllocatedAccounts)
        {
            if (account)
            {
                account_free(account);
                GlobalActiveAccounts--;
            }
        }
        AllocatedAccounts.Empty();

        // Free all allocated providers
        int32 ProviderCount = AllocatedProviders.Num();
        for (Provider* provider : AllocatedProviders)
        {
            if (provider)
            {
                provider_free(provider);
                GlobalActiveProviders--;
            }
        }
        AllocatedProviders.Empty();

        UE_LOG(LogTemp, Log, TEXT("DojoHelpers: Freed %d accounts and %d providers"),
            AccountCount, ProviderCount);
    }
}

void ADojoHelpers::LogResourceUsage() const
{
    FScopeLock Lock(const_cast<FCriticalSection*>(&ResourceMutex));

    UE_LOG(LogTemp, Warning, TEXT("=== Dojo Resource Usage ==="));
    UE_LOG(LogTemp, Warning, TEXT("Local Resources:"));
    UE_LOG(LogTemp, Warning, TEXT("  Active Accounts: %d"), AllocatedAccounts.Num());
    UE_LOG(LogTemp, Warning, TEXT("  Active Providers: %d"), AllocatedProviders.Num());
    UE_LOG(LogTemp, Warning, TEXT("  Torii Client: %s"), toriiClient ? TEXT("Active") : TEXT("Null"));
    UE_LOG(LogTemp, Warning, TEXT("  Subscription: %s"), subscription ? TEXT("Active") : TEXT("Null"));
    UE_LOG(LogTemp, Warning, TEXT("  Subscribed: %s"), subscribed ? TEXT("Yes") : TEXT("No"));

    UE_LOG(LogTemp, Warning, TEXT("Global Resources:"));
    UE_LOG(LogTemp, Warning, TEXT("  Global Torii Clients: %d"), GlobalActiveToriiClients);
    UE_LOG(LogTemp, Warning, TEXT("  Global Accounts: %d"), GlobalActiveAccounts);
    UE_LOG(LogTemp, Warning, TEXT("  Global Providers: %d"), GlobalActiveProviders);
    UE_LOG(LogTemp, Warning, TEXT("  Global Subscriptions: %d"), GlobalActiveSubscriptions);

    // Check for leaks
    if (GlobalActiveAccounts > AllocatedAccounts.Num())
    {
        UE_LOG(LogTemp, Error, TEXT("  WARNING: %d Account(s) may be leaked!"),
            GlobalActiveAccounts - AllocatedAccounts.Num());
    }
    if (GlobalActiveProviders > AllocatedProviders.Num())
    {
        UE_LOG(LogTemp, Error, TEXT("  WARNING: %d Provider(s) may be leaked!"),
            GlobalActiveProviders - AllocatedProviders.Num());
    }

    // Log memory estimates
    // Note: Using estimated sizes as these are opaque types
    const int32 EstimatedAccountSize = 256;  // Estimated size
    const int32 EstimatedProviderSize = 128; // Estimated size
    const int32 EstimatedClientSize = 512;   // Estimated size
    const int32 EstimatedSubscriptionSize = 64; // Estimated size

    int32 EstimatedMemory = 0;
    EstimatedMemory += GlobalActiveAccounts * EstimatedAccountSize;
    EstimatedMemory += GlobalActiveProviders * EstimatedProviderSize;
    EstimatedMemory += GlobalActiveToriiClients * EstimatedClientSize;
    EstimatedMemory += GlobalActiveSubscriptions * EstimatedSubscriptionSize;

    UE_LOG(LogTemp, Warning, TEXT("Estimated Global Memory Usage: %d bytes"), EstimatedMemory);
    UE_LOG(LogTemp, Warning, TEXT("=========================="));
}

void ADojoHelpers::Connect(const FString& torii_url, const FString& world)
{
    UE_LOG(LogTemp, Log, TEXT("ADojoHelpers::Connect - Starting connection"));
    UE_LOG(LogTemp, Log, TEXT("  Torii URL: %s"), *torii_url);
    UE_LOG(LogTemp, Log, TEXT("  World: %s"), *world);

    // Clean up existing client if any
    if (toriiClient)
    {
        UE_LOG(LogTemp, Warning, TEXT("Cleaning up existing Torii client"));
        client_free(toriiClient);
        toriiClient = nullptr;
        GlobalActiveToriiClients--;
    }

    std::string torii_url_string = std::string(TCHAR_TO_UTF8(*torii_url));
    std::string world_string = std::string(TCHAR_TO_UTF8(*world));

    UE_LOG(LogTemp, Log, TEXT("Creating new Torii client..."));
    toriiClient = FDojoModule::CreateToriiClient(torii_url_string.c_str(), world_string.c_str());

    if (toriiClient)
    {
        GlobalActiveToriiClients++;
        UE_LOG(LogTemp, Log, TEXT("Torii Client initialized successfully. Pointer: %p"), toriiClient);
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("Failed to initialize Torii Client!"));
    }
}

void ADojoHelpers::SetContractsAddresses(const TMap<FString,FString>& addresses)
{
    ContractsAddresses = addresses;
}

ADojoHelpers* ADojoHelpers::GetGlobalInstance()
{
    FScopeLock Lock(&InstanceMutex);
    return Instance;
}

void ADojoHelpers::SetGlobalInstance(ADojoHelpers* instance)
{
    FScopeLock Lock(&InstanceMutex);
    Instance = instance;
}

FAccount ADojoHelpers::CreateAccountDeprecated(const FString& rpc_url, const FString& address, const FString& private_key)
{
    FAccount account;

    std::string rpc_url_string = std::string(TCHAR_TO_UTF8(*rpc_url));
    std::string address_string = std::string(TCHAR_TO_UTF8(*address));
    std::string private_key_string = std::string(TCHAR_TO_UTF8(*private_key));

    // Create provider first
    ResultProvider resProvider = provider_new(rpc_url_string.c_str());
    if (resProvider.tag == OkProvider)
    {
        Provider* provider = resProvider.ok;
        FScopeLock Lock(&ResourceMutex);
        AllocatedProviders.Add(provider);
        GlobalActiveProviders++;
    }

    account.account = FDojoModule::CreateAccount(rpc_url_string.c_str(), address_string.c_str(), \
             private_key_string.c_str());

    if (account.account)
    {
        FScopeLock Lock(&ResourceMutex);
        AllocatedAccounts.Add(account.account);
        GlobalActiveAccounts++;
    }

    account.Address = address;
    return account;
}

FAccount ADojoHelpers::CreateBurnerDeprecated(const FString& rpc_url, const FString& address, \
             const FString& private_key)
{
    FAccount account;

    std::string rpc_url_string = std::string(TCHAR_TO_UTF8(*rpc_url));
    std::string address_string = std::string(TCHAR_TO_UTF8(*address));
    std::string private_key_string = std::string(TCHAR_TO_UTF8(*private_key));

    // Create provider first
    ResultProvider resProvider = provider_new(rpc_url_string.c_str());
    if (resProvider.tag == OkProvider)
    {
        Provider* provider = resProvider.ok;
        FScopeLock Lock(&ResourceMutex);
        AllocatedProviders.Add(provider);
        GlobalActiveProviders++;
    }

    Account *master_account = FDojoModule::CreateAccount(rpc_url_string.c_str(), \
             address_string.c_str(), private_key_string.c_str());
    if (master_account == nullptr) {
        account.Address = UTF8_TO_TCHAR("0x0");
        return account;
    }

    // Track master account
    {
        FScopeLock Lock(&ResourceMutex);
        AllocatedAccounts.Add(master_account);
        GlobalActiveAccounts++;
    }

    account.account = FDojoModule::CreateBurner(rpc_url_string.c_str(), master_account);
    if (account.account == nullptr) {
        account.Address = UTF8_TO_TCHAR("0x0");
        return account;
    }

    // Track burner account
    {
        FScopeLock Lock(&ResourceMutex);
        AllocatedAccounts.Add(account.account);
        GlobalActiveAccounts++;
    }

    account.Address = FDojoModule::AccountAddress(account.account);
    return account;
}

void ADojoHelpers::ControllerGetAccountOrConnect(const FString& rpc_url, const FString& \
             chain_id)
{
    std::string rpc_url_string = std::string(TCHAR_TO_UTF8(*rpc_url));
    std::string chain_id_string = std::string(TCHAR_TO_UTF8(*chain_id));

    FieldElement CraftIslandPocketActionsContract;
    FDojoModule::string_to_bytes(std::string(TCHAR_TO_UTF8(*\
    this->ContractsAddresses["craft_island_pocket-actions"])), CraftIslandPocketActionsContract.data, 32);FieldElement CraftIslandPocketAdminContract;
    FDojoModule::string_to_bytes(std::string(TCHAR_TO_UTF8(*\
    this->ContractsAddresses["craft_island_pocket-admin"])), CraftIslandPocketAdminContract.data, 32);
    struct Policy policies[] = {
        { CraftIslandPocketActionsContract, "spawn", "spawn" },
        { CraftIslandPocketActionsContract, "hit_block", "hit_block" },
        { CraftIslandPocketActionsContract, "use_item", "use_item" },
        { CraftIslandPocketActionsContract, "select_hotbar_slot", "select_hotbar_slot" },
        { CraftIslandPocketActionsContract, "craft", "craft" },
        { CraftIslandPocketActionsContract, "inventory_move_item", "inventory_move_item" },
        { CraftIslandPocketActionsContract, "generate_island_part", "generate_island_part" },
        { CraftIslandPocketActionsContract, "visit", "visit" },
        { CraftIslandPocketActionsContract, "visit_new_island", "visit_new_island" },
        { CraftIslandPocketAdminContract, "give_self", "give_self" }
    };
    int nbPolicies = 10;


    FDojoModule::ControllerGetAccountOrConnect(rpc_url_string.c_str(), chain_id_string.c_str(), \
             policies, nbPolicies, ControllerCallbackProxy);
}


void ADojoHelpers::ControllerConnect(const FString& rpc_url)
{
    std::string rpc_url_string = std::string(TCHAR_TO_UTF8(*rpc_url));

    FieldElement CraftIslandPocketActionsContract;
    FDojoModule::string_to_bytes(std::string(TCHAR_TO_UTF8(*\
    this->ContractsAddresses["craft_island_pocket-actions"])), CraftIslandPocketActionsContract.data, 32);FieldElement CraftIslandPocketAdminContract;
    FDojoModule::string_to_bytes(std::string(TCHAR_TO_UTF8(*\
    this->ContractsAddresses["craft_island_pocket-admin"])), CraftIslandPocketAdminContract.data, 32);
    struct Policy policies[] = {
        { CraftIslandPocketActionsContract, "spawn", "spawn" },
        { CraftIslandPocketActionsContract, "hit_block", "hit_block" },
        { CraftIslandPocketActionsContract, "use_item", "use_item" },
        { CraftIslandPocketActionsContract, "select_hotbar_slot", "select_hotbar_slot" },
        { CraftIslandPocketActionsContract, "craft", "craft" },
        { CraftIslandPocketActionsContract, "inventory_move_item", "inventory_move_item" },
        { CraftIslandPocketActionsContract, "generate_island_part", "generate_island_part" },
        { CraftIslandPocketActionsContract, "visit", "visit" },
        { CraftIslandPocketActionsContract, "visit_new_island", "visit_new_island" },
        { CraftIslandPocketAdminContract, "give_self", "give_self" }
    };
    int nbPolicies = 10;


    FDojoModule::ControllerConnect(rpc_url_string.c_str(), policies, nbPolicies, ControllerCallbackProxy);
}

void ADojoHelpers::ControllerCallbackProxy(ControllerAccount *account)
{
    ADojoHelpers* SafeInstance = GetGlobalInstance();
    if (!SafeInstance || !IsValid(SafeInstance)) return;
    SafeInstance->ControllerAccountCallback(account);
}

void ADojoHelpers::ControllerAccountCallback(ControllerAccount *account)
{
    // Going back to Blueprint thread to broadcast the account
    Async(EAsyncExecution::TaskGraphMainThread, [this, account]() {
        FControllerAccount controllerAccount;
        controllerAccount.account = account;
        controllerAccount.Address = FDojoModule::ControllerAccountAddress(account);
        FOnDojoControllerAccount.Broadcast(controllerAccount);
    });
}

void ADojoHelpers::ExecuteRawDeprecated(const FAccount& account, const FString& to, const \
             FString& selector, const FString& calldataParameter)
{
    Async(EAsyncExecution::Thread, [this, account, to, selector, calldataParameter]()
    {
        TArray<std::string> felts;
        if (strcmp(TCHAR_TO_UTF8(*calldataParameter), "") != 0) {
            TArray<FString> Out;
            calldataParameter.ParseIntoArray(Out,TEXT(","),true);
            for (int i = 0; i < Out.Num(); i++) {
                std::string felt = TCHAR_TO_UTF8(*Out[i]);
                felts.Add(felt);
            }
        }
        FDojoModule::ExecuteRaw(account.account, TCHAR_TO_UTF8(*to), TCHAR_TO_UTF8(*selector), \
             felts);
    });
}

void ADojoHelpers::ExecuteFromOutside(const FControllerAccount& account, const FString& to, \
             const FString& selector, const FString& calldataParameter)
{
    Async(EAsyncExecution::Thread, [this, account, to, selector, calldataParameter]()
    {
        TArray<std::string> felts;
        if (strcmp(TCHAR_TO_UTF8(*calldataParameter), "") != 0) {
            TArray<FString> Out;
            calldataParameter.ParseIntoArray(Out,TEXT(","),true);
            for (int i = 0; i < Out.Num(); i++) {
                std::string felt = TCHAR_TO_UTF8(*Out[i]);
                felts.Add(felt);
            }
        }
        FDojoModule::ExecuteFromOutside(account.account, TCHAR_TO_UTF8(*to), \
             TCHAR_TO_UTF8(*selector), felts);
    });
}

void ADojoHelpers::FetchExistingModels()
{
    Async(EAsyncExecution::Thread, [this]() {
        UE_LOG(LogTemp, Log, TEXT("FetchExistingModels: Starting to fetch entities"));
        UE_LOG(LogTemp, Log, TEXT("FetchExistingModels: ToriiClient pointer: %p"), toriiClient);

        ResultPageEntity resEntities = FDojoModule::GetEntities(toriiClient, 1000, nullptr);
        if (resEntities.tag == ErrPageEntity) {
            UE_LOG(LogTemp, Error, TEXT("FetchExistingModels: Failed to fetch entities: %hs"), \
            resEntities.err.message);
            return;
        }

        UE_LOG(LogTemp, Log, TEXT("FetchExistingModels: Successfully fetched entities"));
        CArrayEntity *entities = &resEntities.ok.items;
        UE_LOG(LogTemp, Log, TEXT("FetchExistingModels: Processing %d entities"), entities->data_len);

        for (int i = 0; i < entities->data_len; i++) {
            UE_LOG(LogTemp, Log, TEXT("FetchExistingModels: Processing entity %d of %d"), i + 1, entities->data_len);
            CArrayStruct* models = &entities->data[i].models;
            UE_LOG(LogTemp, Log, TEXT("FetchExistingModels: Entity %d has %d models"), i, models->data_len);
            this->ParseModelsAndSend(models);
        }

        UE_LOG(LogTemp, Log, TEXT("FetchExistingModels: Cleaning up entity data"));
        FDojoModule::CArrayFree(entities->data, entities->data_len);
        UE_LOG(LogTemp, Log, TEXT("FetchExistingModels: Completed successfully"));
    });
}

void ADojoHelpers::SubscribeOnDojoModelUpdate()
{
    UE_LOG(LogTemp, Log, TEXT("SubscribeOnDojoModelUpdate called"));
    if (subscribed) {
        UE_LOG(LogTemp, Warning, TEXT("Warning: cancelled, already subscribed."));
        return;
    }
    if (toriiClient == nullptr) {
        UE_LOG(LogTemp, Error, TEXT("Error: Torii Client is not initialized."));
        return;
    }

    UE_LOG(LogTemp, Log, TEXT("Starting subscription in async thread..."));

    // Run subscription in a background thread to avoid blocking the game thread
    Async(EAsyncExecution::Thread, [this]() {
        UE_LOG(LogTemp, Log, TEXT("Async thread: Starting entity subscription"));
        UE_LOG(LogTemp, Log, TEXT("Async thread: ToriiClient pointer: %p"), toriiClient);

        UE_LOG(LogTemp, Log, TEXT("Async thread: About to call FDojoModule::OnEntityUpdate..."));
        struct ResultSubscription res =
            FDojoModule::OnEntityUpdate(toriiClient, "{}", nullptr, CallbackProxy);
        UE_LOG(LogTemp, Log, TEXT("Async thread: FDojoModule::OnEntityUpdate returned"));

        // Process result back on game thread
        Async(EAsyncExecution::TaskGraphMainThread, [this, res]() {
            // Check if subscription was successful
            if (res.tag == ErrSubscription)
            {
                UE_LOG(LogTemp, Error, TEXT("Failed to create subscription: %hs"), res.err.message);
                subscribed = false;
                return;
            }

            if (res.tag == OkSubscription && res.ok != nullptr)
            {
                subscription = res.ok;
                subscribed = true;
                GlobalActiveSubscriptions++;
                UE_LOG(LogTemp, Log, TEXT("Entity subscription created successfully"));
            }
            else
            {
                UE_LOG(LogTemp, Error, TEXT("Subscription returned OK but with null subscription pointer"));
                subscribed = false;
            }
        });
    });
}

void ADojoHelpers::CallbackProxy(struct FieldElement key, struct CArrayStruct models)
{
    ADojoHelpers* SafeInstance = GetGlobalInstance();
    if (!SafeInstance || !IsValid(SafeInstance))
    {
        UE_LOG(LogTemp, Error, TEXT("CallbackProxy: SafeInstance is null or invalid"));
        return;
    }

    SafeInstance->ParseModelsAndSend(&models);
}

template<typename T>
static void ConvertTyToUnrealEngineType(const Member* member, const char* expectedName, const \
             char* expectedType, T& output);

class TypeConverter {
public:
    static FString ConvertToFString(const Member* member) {
        switch (member->ty->primitive.tag) {
            case Primitive_Tag::ContractAddress:
                return FDojoModule::bytes_to_fstring(member->ty->primitive.contract_address.data, \
             32);
            case Primitive_Tag::I128:
                return FDojoModule::bytes_to_fstring(member->ty->primitive.i128, 16);
            case Primitive_Tag::U128:
                return FDojoModule::bytes_to_fstring(member->ty->primitive.u128, 16);
            case Primitive_Tag::Felt252:
                return FDojoModule::bytes_to_fstring(member->ty->primitive.felt252.data, 32);
            case Primitive_Tag::ClassHash:
                return FDojoModule::bytes_to_fstring(member->ty->primitive.class_hash.data, 32);
            case Primitive_Tag::EthAddress:
                return FDojoModule::bytes_to_fstring(member->ty->primitive.eth_address.data, 32);
            default:
                return FString();
        }
    }

    static int ConvertToInt(const Member* member) {
        switch(member->ty->primitive.tag) {
            case Primitive_Tag::I8:  return member->ty->primitive.i8;
            case Primitive_Tag::I16: return member->ty->primitive.i16;
            case Primitive_Tag::I32: return member->ty->primitive.i32;
            case Primitive_Tag::U8:  return member->ty->primitive.u8;
            case Primitive_Tag::U16: return member->ty->primitive.u16;
            case Primitive_Tag::U32: return member->ty->primitive.u32;
            default: return 0;
        }
    }

    static int64 ConvertToLong(const Member* member) {
        switch(member->ty->primitive.tag) {
            case Primitive_Tag::I64: return member->ty->primitive.i64;
            case Primitive_Tag::U64: return member->ty->primitive.u64;
            default: return 0;
        }
    }

    static bool ConvertToBool(const Member* member) {
        if (member->ty->primitive.tag == Primitive_Tag::Bool) {
            return member->ty->primitive.bool_;
        }
        return false;
    }

    template<typename T>
    static TArray<T> ConvertToArray(const Member* member) {
        TArray<T> result;
        if (member->ty->tag == Ty_Tag::Array_) {
            // Implémenter la logique de conversion d'array
            // Accéder à member->ty->array pour les données
        }
        return result;
    }


};

template<typename T>
static TArray<FString> ConvertToFeltHexa(const T& value, const char* valueType) {
    if constexpr (std::is_same_v<T, FString>) {
        if (strcmp(valueType, "i128") == 0 ||
            strcmp(valueType, "u128") == 0 ||
            strcmp(valueType, "u256") == 0 ||
            strcmp(valueType, "felt252") == 0 ||
            strcmp(valueType, "bytes31") == 0 ||
            strcmp(valueType, "ClassHash") == 0 ||
            strcmp(valueType, "ContractAddress") == 0 ||
            strcmp(valueType, "ByteArray") == 0) {

            // Remove "0x" if present
            FString hexValue = value;
            if (hexValue.StartsWith(TEXT("0x"))) {
                hexValue.RightChopInline(2);
            }

            // Pad with leading zeros to make it 64 characters
            while (hexValue.Len() < 64) {
                hexValue = TEXT("0") + hexValue;
            }

            // Truncate if longer than 64 characters
            if (hexValue.Len() > 64) {
                hexValue = hexValue.Right(64);
            }

            return TArray<FString>{TEXT("0x") + hexValue};
        }
    }
    else if constexpr (std::is_same_v<T, int>) {
        if (strcmp(valueType, "i8") == 0 ||
            strcmp(valueType, "i16") == 0 ||
            strcmp(valueType, "i32") == 0 ||
            strcmp(valueType, "u8") == 0 ||
            strcmp(valueType, "u16") == 0 ||
            strcmp(valueType, "u32") == 0) {
            FString hexValue = FString::Printf(TEXT("%X"), static_cast<int>(value));
            while (hexValue.Len() < 64) {
                hexValue = TEXT("0") + hexValue;
            }
            return TArray<FString>{TEXT("0x") + hexValue};
        }
    }
    else if constexpr (std::is_same_v<T, int64>) {
        if (strcmp(valueType, "u64") == 0 ||
            strcmp(valueType, "i64") == 0) {
            FString hexValue = FString::Printf(TEXT("%X"), static_cast<int64>(value));
            while (hexValue.Len() < 64) {
                hexValue = TEXT("0") + hexValue;
            }
            return TArray<FString>{TEXT("0x") + hexValue};
        }
    }
    else if constexpr (std::is_same_v<T, bool>) {
        if (strcmp(valueType, "bool") == 0) {
            FString hexValue = FString::Printf(TEXT("%X"), value ? 1 : 0);
            while (hexValue.Len() < 64) {
                hexValue = TEXT("0") + hexValue;
            }
            return TArray<FString>{TEXT("0x") + hexValue};
        }
    }
    else if constexpr (std::is_same_v<T, TArray<int>>) {
        if (strcmp(valueType, "array") == 0) {
            TArray<FString> strings;
            FString hexValue = FString::Printf(TEXT("%X"), static_cast<int>(value.Num()));
            while (hexValue.Len() < 64) {
                hexValue = TEXT("0") + hexValue;
            }
            strings.Add(TEXT("0x") + hexValue);

            // Add array elements
            for (const int& element : value) {
                FString elementHexValue = FString::Printf(TEXT("%X"), element);
                while (elementHexValue.Len() < 64) {
                    elementHexValue = TEXT("0") + elementHexValue;
                }
                strings.Add(TEXT("0x") + elementHexValue);
            }

            return strings;
        }
    }

    // Default return value padded to 64 characters
    return TArray<FString>{TEXT("0x") + FString::ChrN(64, TEXT('0'))};
}

template<typename T>
static void ConvertTyToUnrealEngineType(const Member* member, const char* expectedName, const char* expectedType, T& output) {
    if (strcmp(member->name, expectedName) != 0) {
        return;
    }

    if constexpr (std::is_same_v<T, FString>) {
        if (strcmp(expectedType, "i128") == 0 ||
            strcmp(expectedType, "u128") == 0 ||
            strcmp(expectedType, "u256") == 0 ||
            strcmp(expectedType, "felt252") == 0 ||
            strcmp(expectedType, "bytes31") == 0 ||
            strcmp(expectedType, "ClassHash") == 0 ||
            strcmp(expectedType, "ContractAddress") == 0 ||
            strcmp(expectedType, "ByteArray") == 0) {
            output = TypeConverter::ConvertToFString(member);
        }
    }
    else if constexpr (std::is_same_v<T, int>) {
        if (strcmp(expectedType, "i8") == 0 ||
        strcmp(expectedType, "i16") == 0 ||
        strcmp(expectedType, "i32") == 0 ||
        strcmp(expectedType, "u8") == 0 ||
        strcmp(expectedType, "u16") == 0 ||
        strcmp(expectedType, "u32") == 0) {
            output = TypeConverter::ConvertToInt(member);
        }
    }
    else if constexpr (std::is_same_v<T, int64>) {
        if (strcmp(expectedType, "i64") == 0 ||
        strcmp(expectedType, "u64") == 0 ||
        strcmp(expectedType, "usize") == 0) {
            output = TypeConverter::ConvertToLong(member);
        }
    }
    else if constexpr (std::is_same_v<T, bool>) {
        if (strcmp(expectedType, "bool") == 0) {
            output = TypeConverter::ConvertToBool(member);
        }
    }

}



UDojoModel* ADojoHelpers::parseCraftIslandPocketGatherableResourceModel(struct Struct* model)
{
    UDojoModelCraftIslandPocketGatherableResource* Model = NewObject<UDojoModelCraftIslandPocketGatherableResource>(GetTransientPackage());
    CArrayMember* members = &model->children;

    for (int k = 0; k < members->data_len; k++) {
        Member* member = &members->data[k];
        ConvertTyToUnrealEngineType(member, "island_owner", "felt252", Model->IslandOwner);
        ConvertTyToUnrealEngineType(member, "island_id", "u16", Model->IslandId);
        ConvertTyToUnrealEngineType(member, "chunk_id", "u128", Model->ChunkId);
        ConvertTyToUnrealEngineType(member, "position", "u8", Model->Position);
        ConvertTyToUnrealEngineType(member, "resource_id", "u16", Model->ResourceId);
        ConvertTyToUnrealEngineType(member, "planted_at", "u64", Model->PlantedAt);
        ConvertTyToUnrealEngineType(member, "next_harvest_at", "u64", Model->NextHarvestAt);
        ConvertTyToUnrealEngineType(member, "harvested_at", "u64", Model->HarvestedAt);
        ConvertTyToUnrealEngineType(member, "max_harvest", "u8", Model->MaxHarvest);
        ConvertTyToUnrealEngineType(member, "remained_harvest", "u8", Model->RemainedHarvest);
        ConvertTyToUnrealEngineType(member, "destroyed", "bool", Model->Destroyed);
        ConvertTyToUnrealEngineType(member, "tier", "u8", Model->Tier);
    }

    FDojoModule::CArrayFree(members->data, members->data_len);
    return Model;
}

UDojoModel* ADojoHelpers::parseCraftIslandPocketInventoryModel(struct Struct* model)
{
    UDojoModelCraftIslandPocketInventory* Model = NewObject<UDojoModelCraftIslandPocketInventory>(GetTransientPackage());
    CArrayMember* members = &model->children;

    for (int k = 0; k < members->data_len; k++) {
        Member* member = &members->data[k];
        ConvertTyToUnrealEngineType(member, "owner", "ContractAddress", Model->Owner);
        ConvertTyToUnrealEngineType(member, "id", "u16", Model->Id);
        ConvertTyToUnrealEngineType(member, "inventory_type", "u8", Model->InventoryType);
        ConvertTyToUnrealEngineType(member, "inventory_size", "u8", Model->InventorySize);
        ConvertTyToUnrealEngineType(member, "slots1", "felt252", Model->Slots1);
        ConvertTyToUnrealEngineType(member, "slots2", "felt252", Model->Slots2);
        ConvertTyToUnrealEngineType(member, "slots3", "felt252", Model->Slots3);
        ConvertTyToUnrealEngineType(member, "slots4", "felt252", Model->Slots4);
        ConvertTyToUnrealEngineType(member, "hotbar_selected_slot", "u8", Model->HotbarSelectedSlot);
        ConvertTyToUnrealEngineType(member, "readonly", "bool", Model->Readonly);
    }

    FDojoModule::CArrayFree(members->data, members->data_len);
    return Model;
}

UDojoModel* ADojoHelpers::parseCraftIslandPocketIslandChunkModel(struct Struct* model)
{
    UDojoModelCraftIslandPocketIslandChunk* Model = NewObject<UDojoModelCraftIslandPocketIslandChunk>(GetTransientPackage());
    CArrayMember* members = &model->children;

    for (int k = 0; k < members->data_len; k++) {
        Member* member = &members->data[k];
        ConvertTyToUnrealEngineType(member, "island_owner", "felt252", Model->IslandOwner);
        ConvertTyToUnrealEngineType(member, "island_id", "u16", Model->IslandId);
        ConvertTyToUnrealEngineType(member, "chunk_id", "u128", Model->ChunkId);
        ConvertTyToUnrealEngineType(member, "version", "u8", Model->Version);
        ConvertTyToUnrealEngineType(member, "blocks1", "u128", Model->Blocks1);
        ConvertTyToUnrealEngineType(member, "blocks2", "u128", Model->Blocks2);
    }

    FDojoModule::CArrayFree(members->data, members->data_len);
    return Model;
}

UDojoModel* ADojoHelpers::parseCraftIslandPocketPlayerDataModel(struct Struct* model)
{
    UDojoModelCraftIslandPocketPlayerData* Model = NewObject<UDojoModelCraftIslandPocketPlayerData>(GetTransientPackage());
    CArrayMember* members = &model->children;

    for (int k = 0; k < members->data_len; k++) {
        Member* member = &members->data[k];
        ConvertTyToUnrealEngineType(member, "player", "ContractAddress", Model->Player);
        ConvertTyToUnrealEngineType(member, "last_inventory_created_id", "u16", Model->LastInventoryCreatedId);
        ConvertTyToUnrealEngineType(member, "last_space_created_id", "u16", Model->LastSpaceCreatedId);
        ConvertTyToUnrealEngineType(member, "current_space_owner", "felt252", Model->CurrentSpaceOwner);
        ConvertTyToUnrealEngineType(member, "current_space_id", "u16", Model->CurrentSpaceId);
        ConvertTyToUnrealEngineType(member, "coins", "u32", Model->Coins);
        ConvertTyToUnrealEngineType(member, "random_nonce", "u32", Model->RandomNonce);
    }

    FDojoModule::CArrayFree(members->data, members->data_len);
    return Model;
}

UDojoModel* ADojoHelpers::parseCraftIslandPocketPlayerStatsModel(struct Struct* model)
{
    UDojoModelCraftIslandPocketPlayerStats* Model = NewObject<UDojoModelCraftIslandPocketPlayerStats>(GetTransientPackage());
    CArrayMember* members = &model->children;

    for (int k = 0; k < members->data_len; k++) {
        Member* member = &members->data[k];
        ConvertTyToUnrealEngineType(member, "player", "ContractAddress", Model->Player);
        ConvertTyToUnrealEngineType(member, "miner_level", "u8", Model->MinerLevel);
        ConvertTyToUnrealEngineType(member, "lumberjack_level", "u8", Model->LumberjackLevel);
        ConvertTyToUnrealEngineType(member, "farmer_level", "u8", Model->FarmerLevel);
        ConvertTyToUnrealEngineType(member, "miner_xp", "u32", Model->MinerXp);
        ConvertTyToUnrealEngineType(member, "lumberjack_xp", "u32", Model->LumberjackXp);
        ConvertTyToUnrealEngineType(member, "farmer_xp", "u32", Model->FarmerXp);
    }

    FDojoModule::CArrayFree(members->data, members->data_len);
    return Model;
}

UDojoModel* ADojoHelpers::parseCraftIslandPocketWorldStructureModel(struct Struct* model)
{
    UDojoModelCraftIslandPocketWorldStructure* Model = NewObject<UDojoModelCraftIslandPocketWorldStructure>(GetTransientPackage());
    CArrayMember* members = &model->children;

    for (int k = 0; k < members->data_len; k++) {
        Member* member = &members->data[k];
        ConvertTyToUnrealEngineType(member, "island_owner", "felt252", Model->IslandOwner);
        ConvertTyToUnrealEngineType(member, "island_id", "u16", Model->IslandId);
        ConvertTyToUnrealEngineType(member, "chunk_id", "u128", Model->ChunkId);
        ConvertTyToUnrealEngineType(member, "position", "u8", Model->Position);
        ConvertTyToUnrealEngineType(member, "structure_type", "u8", Model->StructureType);
        ConvertTyToUnrealEngineType(member, "build_inventory_id", "u16", Model->BuildInventoryId);
        ConvertTyToUnrealEngineType(member, "completed", "bool", Model->Completed);
        ConvertTyToUnrealEngineType(member, "linked_space_owner", "felt252", Model->LinkedSpaceOwner);
        ConvertTyToUnrealEngineType(member, "linked_space_id", "u16", Model->LinkedSpaceId);
        ConvertTyToUnrealEngineType(member, "destroyed", "bool", Model->Destroyed);
    }

    FDojoModule::CArrayFree(members->data, members->data_len);
    return Model;
}

UDojoModel* ADojoHelpers::parseCraftIslandPocketProcessingLockModel(struct Struct* model)
{
    UDojoModelCraftIslandPocketProcessingLock* Model = NewObject<UDojoModelCraftIslandPocketProcessingLock>(GetTransientPackage());
    CArrayMember* members = &model->children;

    for (int k = 0; k < members->data_len; k++) {
        Member* member = &members->data[k];
        ConvertTyToUnrealEngineType(member, "player", "felt252", Model->Player);
        ConvertTyToUnrealEngineType(member, "unlock_time", "u64", Model->UnlockTime);
        ConvertTyToUnrealEngineType(member, "process_type", "u8", Model->ProcessType);
        ConvertTyToUnrealEngineType(member, "batches_processed", "u32", Model->BatchesProcessed);
    }

    FDojoModule::CArrayFree(members->data, members->data_len);
    return Model;
}

void ADojoHelpers::ParseModelsAndSend(struct CArrayStruct* models)
{
    if (!models || !models->data)
    {
        UE_LOG(LogTemp, Warning, TEXT("ParseModelsAndSend: Invalid input models"));
        return;
    }

    TArray<UDojoModel*> ParsedModels;
    ParsedModels.Reserve(models->data_len);

    for (int32 Index = 0; Index < models->data_len; ++Index)
    {
        const char* ModelName = models->data[Index].name;
        if (!ModelName)
        {
            UE_LOG(LogTemp, Warning, TEXT("ParseModelsAndSend: null model name (%d)"), Index);
            continue;
        }

        UDojoModel* ParsedModel = nullptr;

        if (strcmp(ModelName, "craft_island_pocket-GatherableResource") == 0)
        {
            ParsedModel = \
                     ADojoHelpers::parseCraftIslandPocketGatherableResourceModel(&\
                     models->data[Index]);
        }
        else if (strcmp(ModelName, "craft_island_pocket-Inventory") == 0)
        {
            ParsedModel = \
                     ADojoHelpers::parseCraftIslandPocketInventoryModel(&\
                     models->data[Index]);
        }
        else if (strcmp(ModelName, "craft_island_pocket-IslandChunk") == 0)
        {
            ParsedModel = \
                     ADojoHelpers::parseCraftIslandPocketIslandChunkModel(&\
                     models->data[Index]);
        }
        else if (strcmp(ModelName, "craft_island_pocket-PlayerData") == 0)
        {
            ParsedModel = \
                     ADojoHelpers::parseCraftIslandPocketPlayerDataModel(&\
                     models->data[Index]);
        }
        else if (strcmp(ModelName, "craft_island_pocket-PlayerStats") == 0)
        {
            ParsedModel = \
                     ADojoHelpers::parseCraftIslandPocketPlayerStatsModel(&\
                     models->data[Index]);
        }
        else if (strcmp(ModelName, "craft_island_pocket-WorldStructure") == 0)
        {
            ParsedModel = \
                     ADojoHelpers::parseCraftIslandPocketWorldStructureModel(&\
                     models->data[Index]);
        }
        else if (strcmp(ModelName, "craft_island_pocket-ProcessingLock") == 0)
        {
            ParsedModel = \
                     ADojoHelpers::parseCraftIslandPocketProcessingLockModel(&\
                     models->data[Index]);
        }
        else
        {
            UE_LOG(LogTemp, Warning, TEXT("ParseModelsAndSend: Unknown model type %s"), \
             UTF8_TO_TCHAR(ModelName));
            continue;
        }

        if (ParsedModel)
        {
            ParsedModel->DojoModelType = ModelName;
            ParsedModels.Add(ParsedModel);
        }
        else
        {
            UE_LOG(LogTemp, Warning, TEXT("ParseModelsAndSend: Failed to parse model %s"), \
             UTF8_TO_TCHAR(ModelName));
        }
    }

    if (ParsedModels.Num() > 0)
    {
        AsyncTask(ENamedThreads::GameThread, [this, ParsedModels = MoveTemp(ParsedModels)]()
        {
            for (UDojoModel* Model : ParsedModels)
            {
                if (IsValid(Model))
                {
                    OnDojoModelUpdated.Broadcast(Model);
                }
            }
        });
    }

    // Cleanup
    if (models->data)
    {
        FDojoModule::CArrayFree(models->data, models->data_len);
    }
}


void ADojoHelpers::CallCraftIslandPocketActionsSpawn(const FAccount& account) {
    TArray<FString> args;

    this->ExecuteRawDeprecated(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("spawn"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallControllerCraftIslandPocketActionsSpawn(const FControllerAccount& \
                     account) {
    TArray<FString> args;

    this->ExecuteFromOutside(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("spawn"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallCraftIslandPocketActionsHitBlock(const FAccount& account, int64 x, int64 y, int64 z, int hp) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int64>(x, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(y, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(z, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int>(hp, \
                                 "u32"));
    this->ExecuteRawDeprecated(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("hit_block"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallControllerCraftIslandPocketActionsHitBlock(const FControllerAccount& \
                     account, int64 x, int64 y, int64 z, int hp) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int64>(x, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(y, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(z, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int>(hp, \
                                 "u32"));
    this->ExecuteFromOutside(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("hit_block"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallCraftIslandPocketActionsUseItem(const FAccount& account, int64 x, int64 y, int64 z) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int64>(x, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(y, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(z, \
                                 "u64"));
    this->ExecuteRawDeprecated(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("use_item"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallControllerCraftIslandPocketActionsUseItem(const FControllerAccount& \
                     account, int64 x, int64 y, int64 z) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int64>(x, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(y, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(z, \
                                 "u64"));
    this->ExecuteFromOutside(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("use_item"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallCraftIslandPocketActionsSelectHotbarSlot(const FAccount& account, int slot) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int>(slot, \
                                 "u8"));
    this->ExecuteRawDeprecated(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("select_hotbar_slot"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallControllerCraftIslandPocketActionsSelectHotbarSlot(const FControllerAccount& \
                     account, int slot) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int>(slot, \
                                 "u8"));
    this->ExecuteFromOutside(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("select_hotbar_slot"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallCraftIslandPocketActionsCraft(const FAccount& account, int item, int64 x, int64 y, int64 z) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int>(item, \
                                 "u32"));
    args.Append(ConvertToFeltHexa<int64>(x, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(y, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(z, \
                                 "u64"));
    this->ExecuteRawDeprecated(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("craft"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallControllerCraftIslandPocketActionsCraft(const FControllerAccount& \
                     account, int item, int64 x, int64 y, int64 z) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int>(item, \
                                 "u32"));
    args.Append(ConvertToFeltHexa<int64>(x, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(y, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(z, \
                                 "u64"));
    this->ExecuteFromOutside(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("craft"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallCraftIslandPocketActionsInventoryMoveItem(const FAccount& account, int from_inventory, int from_slot, int to_inventory_id, int to_slot) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int>(from_inventory, \
                                 "u16"));
    args.Append(ConvertToFeltHexa<int>(from_slot, \
                                 "u8"));
    args.Append(ConvertToFeltHexa<int>(to_inventory_id, \
                                 "u16"));
    args.Append(ConvertToFeltHexa<int>(to_slot, \
                                 "u8"));
    this->ExecuteRawDeprecated(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("inventory_move_item"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallControllerCraftIslandPocketActionsInventoryMoveItem(const FControllerAccount& \
                     account, int from_inventory, int from_slot, int to_inventory_id, int to_slot) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int>(from_inventory, \
                                 "u16"));
    args.Append(ConvertToFeltHexa<int>(from_slot, \
                                 "u8"));
    args.Append(ConvertToFeltHexa<int>(to_inventory_id, \
                                 "u16"));
    args.Append(ConvertToFeltHexa<int>(to_slot, \
                                 "u8"));
    this->ExecuteFromOutside(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("inventory_move_item"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallCraftIslandPocketActionsGenerateIslandPart(const FAccount& account, int64 x, int64 y, int64 z, int island_id) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int64>(x, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(y, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(z, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int>(island_id, \
                                 "u16"));
    this->ExecuteRawDeprecated(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("generate_island_part"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallControllerCraftIslandPocketActionsGenerateIslandPart(const FControllerAccount& \
                     account, int64 x, int64 y, int64 z, int island_id) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int64>(x, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(y, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int64>(z, \
                                 "u64"));
    args.Append(ConvertToFeltHexa<int>(island_id, \
                                 "u16"));
    this->ExecuteFromOutside(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("generate_island_part"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallCraftIslandPocketActionsVisit(const FAccount& account, int space_id) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int>(space_id, \
                                 "u16"));
    this->ExecuteRawDeprecated(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("visit"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallControllerCraftIslandPocketActionsVisit(const FControllerAccount& \
                     account, int space_id) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int>(space_id, \
                                 "u16"));
    this->ExecuteFromOutside(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("visit"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallCraftIslandPocketActionsVisitNewIsland(const FAccount& account) {
    TArray<FString> args;

    this->ExecuteRawDeprecated(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("visit_new_island"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallControllerCraftIslandPocketActionsVisitNewIsland(const FControllerAccount& \
                     account) {
    TArray<FString> args;

    this->ExecuteFromOutside(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("visit_new_island"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallCraftIslandPocketAdminGiveSelf(const FAccount& account, int item, int qty) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int>(item, \
                                 "u16"));
    args.Append(ConvertToFeltHexa<int>(qty, \
                                 "u32"));
    this->ExecuteRawDeprecated(account, this->ContractsAddresses["craft_island_pocket-admin"], \
                     TEXT("give_self"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallControllerCraftIslandPocketAdminGiveSelf(const FControllerAccount& \
                     account, int item, int qty) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int>(item, \
                                 "u16"));
    args.Append(ConvertToFeltHexa<int>(qty, \
                                 "u32"));
    this->ExecuteFromOutside(account, this->ContractsAddresses["craft_island_pocket-admin"], \
                     TEXT("give_self"), FString::Join(args, TEXT(",")));
}


void ADojoHelpers::CallCraftIslandPocketActionsSell(const FAccount& account) {
    TArray<FString> args;
    this->ExecuteRawDeprecated(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("sell"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallControllerCraftIslandPocketActionsSell(const FControllerAccount& account) {
    TArray<FString> args;
    this->ExecuteFromOutside(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("sell"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallCraftIslandPocketActionsBuy(const FAccount& account, int32 ItemId, int32 Quantity) {
    TArray<FString> args;
    // Create arrays for item_ids and quantities
    args.Add(FString::Printf(TEXT("1"))); // Array length for item_ids
    args.Append(ConvertToFeltHexa<int>(ItemId, "u16")); // Item ID as u16
    args.Add(FString::Printf(TEXT("1"))); // Array length for quantities  
    args.Append(ConvertToFeltHexa<int>(Quantity, "u32")); // Quantity as u32
    this->ExecuteRawDeprecated(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("buy"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallControllerCraftIslandPocketActionsBuy(const FControllerAccount& account, int32 ItemId, int32 Quantity) {
    TArray<FString> args;
    // Create arrays for item_ids and quantities
    args.Add(FString::Printf(TEXT("1"))); // Array length for item_ids
    args.Append(ConvertToFeltHexa<int>(ItemId, "u16")); // Item ID as u16
    args.Add(FString::Printf(TEXT("1"))); // Array length for quantities
    args.Append(ConvertToFeltHexa<int>(Quantity, "u32")); // Quantity as u32
    this->ExecuteFromOutside(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("buy"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallCraftIslandPocketActionsStartProcessing(const FAccount& account, int32 ProcessType, int32 InputAmount) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int>(ProcessType, "u8")); // Process type as u8
    args.Append(ConvertToFeltHexa<int>(InputAmount, "u32")); // Input amount as u32
    this->ExecuteRawDeprecated(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("start_processing"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallControllerCraftIslandPocketActionsStartProcessing(const FControllerAccount& account, int32 ProcessType, int32 InputAmount) {
    TArray<FString> args;
    args.Append(ConvertToFeltHexa<int>(ProcessType, "u8")); // Process type as u8
    args.Append(ConvertToFeltHexa<int>(InputAmount, "u32")); // Input amount as u32
    this->ExecuteFromOutside(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("start_processing"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallCraftIslandPocketActionsCancelProcessing(const FAccount& account) {
    TArray<FString> args;
    this->ExecuteRawDeprecated(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("cancel_processing"), FString::Join(args, TEXT(",")));
}

void ADojoHelpers::CallControllerCraftIslandPocketActionsCancelProcessing(const FControllerAccount& account) {
    TArray<FString> args;
    this->ExecuteFromOutside(account, this->ContractsAddresses["craft_island_pocket-actions"], \
                     TEXT("cancel_processing"), FString::Join(args, TEXT(",")));
}
